<html>
  <head>
    <meta charset="UTF-8" />
    <title>출력결과</title>
  </head>
  <body>
    <script>
      /*
        [선택 정렬]
        하나의 자리를 선택하여 그 자리 수 와 전체를 비교하며 가장 작은 수를 넣는 정렬법
        - 이중 포문으로 구현
        - 외부 포문은 0부터 arr.length전 까지 / 내부 포문은 index+1부터 arr.length전까지
        - 내부 포문 돌기 전, 가장 작은 인덱스 할당
        - 내부 포문을 돌며, 가장 작은 인덱스와 교환

        [버블 정렬]
        앞 뒤를 비교하여 마지막부터 가장 큰수를 먼저 맞추는 정렬법
        - 이중 포문으로 구현
        - 외부 포문은 arr.length부터 0전 까지 줄어들기 / 내부 포문은 0부터 i-1전까지
        - 외부는 뒤부터 / 내부는 앞부터
        - 앞 뒤를 비교하여, 바로 뒤가 앞보다 크면 교환

        [삽입 정렬]
        지정 index의 앞부터 0인덱스까지 index의 값과 비교하여 index가 있을 자리를 하나씩 넘겨가며 찾는 정렬법
        다음 index의 값에 선택된 값과 비교후 변경해주는 것이 포인트
        - 이중 포문으로 구현
        - 외부 포문은 1부터 arr.length전 까지 / 내부 포문은 i-1부터 0까지 줄어들기
        - 내부 포문을 돌기 전, 선택된 인덱스의 값 저장
        - 만약 내부 포문을 돌며, 선택 인덱스의 값보다 크다면, 선택 인덱스와 교환이 아닌, 다음 인덱스의 값에 넣어줌(교환x)
        - 그리고, 0값까지 j가 가게되었다면, 저장된 인덱스 값을 인덱스0 값에 넣어줌
        - 만약 그 외로, 크거나 같은 값이 발견되면 저장한 index값을 다음 인덱스의 값에 넣어주고, 순환 정지

        [이분 검색]
        - 오름차순으로 정렬 후, 반으로 쪼개가며 검색
        - leftPoint, rightPoint를 처음과 끝으로 할당
        - while문으로 leftPoint보다 rightPoint가 크거나 같을떄까지로 설정
        - middle은 leftPoint + rightPoint 나누기 2에서 내림
        - 만약 middle과 타겟이 같다면, answer는 middle +1 (순서기 때문) 그리고 break
        - 타겟이 middle보다 작다면, rightPoint가 middle -1
        - 타겟이 middle보다 크다면, leftPoint middle+1

        [이분 탐색 심화]
        - 지정된 것이 아닌, 그 중 가장 작은것 혹은 가장 큰것을 찾아나가는것
        - 이때는 while로 모든 문을 다 돈다고 생각
        - 이떄 구하려는 값과 그 값을 구하는 함수를 구하기
        - 그리고 답이 될 수 있는 곳에서 비교해주기 중요 포인트는 만약 답이 될 수 있는 것이 나왔더라도, 
        - 여기서 middle의 수를 올려주거나 내려주어 범위를 계속 올려주는것
        */
    </script>
  </body>
</html>
